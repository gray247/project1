/**
 * SnipBoard Module: renderer.js
 *
 * Responsibilities:
 *  - Bootstrap SnipBoard UI modules (tabs, clips, modals, editor).
 *  - Wire high-level event handlers and application lifecycle.
 *  - Coordinate refresh/polling and IPC-driven data loading.
 *
 * Exports:
 *  - None; runs as the renderer entry point.
 *
 * Does NOT handle:
 *  - Direct tab/clip/editor rendering (delegated to ui_* modules).
 *  - IPC channel definitions or low-level DOM styling.
 *
 * Dependencies:
 *  - SnipState, SnipIPC, SnipTabs, SnipClips, SnipEditor, SnipModals globals.
 *  - DOM structure defined in index.html.
 *
 * Notes:
 *  - Glue-only file; logic lives in injected modules.
 *  - Uses AppState from SnipState for shared cross-module state.
 *
 * Renderer Call Flow:
 *   init() →
 *     load state via IPC →
 *     initTabs →
 *     initClips →
 *     initModals →
 *     initEditor →
 *     bind events →
 *     render initial UI →
 *     start polling loop
 *
 * Consumes API from:
 *  - SnipState
 *  - SnipIPC
 *  - SnipModals
 *  - SnipTabs
 *  - SnipClips
 *  - SnipEditor
 */
const {
  AppState,
  DEFAULT_CLIP_DISPLAY,
  DEFAULT_SCHEMA,
  FIELD_OPTIONS,
  TAB_COLORS,
  DEFAULT_TABS,
  EXPORT_BASE,
  sectionLabel,
  computeSignature,
  normalizeClip,
  slugifyTabName,
  canonicalExportPath,
  normalizeExportPath,
  normalizeTabs,
  tabsToSections,
  sectionsToTabs,
  iconChoices,
  formatDateTime,
  updateSearchIndex,
  validateText,
  validateUrl,
} = window.SnipState || {};

const {
  CHANNELS,
  invoke: rawInvoke,
  safeInvoke,
  send,
  on,
} = window.SnipIPC || {};
const invoke = safeInvoke || rawInvoke;
const { initTabs } = window.SnipTabs || {};
const { initClips } = window.SnipClips || {};
const { initEditor } = window.SnipEditor || {};

let openClipIconPicker;
let openClipColorPicker;
let openRenameModal;
let closeRenameModal;
let openScreenshotModal;
let closeScreenshotModal;
let getTabColorForClip;
let syncSectionsFromTabs;
let syncTabsToBackend;
let getActiveTab;
let updateSidebarHeader;
let renderSectionsBar;
let renderTabs;
let setCurrentSection;
let startInlineRename;
let commitRename;
let cancelRename;
let startTabReorder;
let finishTabReorder;
let closeTabContextMenu;
let openTabContextMenu;
let openSchemaConfigurator;
let toggleLockSection;
let deleteSection;
let handleCreateTab;
let assignExportFolder;
let selectTabColor;
let selectTabIcon;
let moveClipToTab;
let scheduleSaveTabsConfig;
let saveTabsState;
let setTabsModalsApi;
let renderClipList;
let updateActiveClip;
let wireClipEvents;
let closeClipDisplayMenu;
let persistClipAppearance;
let getSelectedClipIds;
let setClipsModalsApi;
let setTabsEditorApi;
let onTabChangeTabs;
let getActiveTabSchema;
let getActiveTabId;
let setClipsEditorApi;
let onClipSelected;
let applyTagFilterValue;
const renderClipListProxy = (...args) => (typeof renderClipList === "function" ? renderClipList(...args) : undefined);
let loadClipIntoEditor;
let bindEditorEvents;
let saveClip;
let deleteClip;
let getEditorFieldValues;
let tabsRenderColorPalette;
let tabsCreateIconGlyph;
let tabsFindIconChoice;
let tabsIconChoices;
let applySchemaVisibilityEditor;

// ===============================================================
// SnipBoard – CLEAN WORKING RENDERER
// ===============================================================

console.log("[SnipBoard] renderer.js loaded");

const state = window.SnipState.AppState;

async function reloadTabsConfig() {
  try {
    const tabsConfig = await invoke(CHANNELS.LOAD_TABS);
    state.tabs = normalizeTabs(tabsConfig?.tabs);
    state.sections = tabsToSections(state.tabs);
    if (tabsConfig?.activeTabId) {
      state.activeTabId = tabsConfig.activeTabId;
    }
    window.tabsState = {
      tabs: state.tabs,
      activeTabId: state.activeTabId || "all",
    };
    if (typeof renderSectionsBar === "function") renderSectionsBar();
  } catch (err) {
    console.warn("[SnipBoard] reloadTabsConfig failed:", err);
  }
}

const SNIPBOARD_COLORS = TAB_COLORS;
let searchIndex = state.searchIndex || new Map();
let draggingClipId = state.draggingClipId;

let lastPollSignature = "";
let handlersBound = false;
const protectedSections = new Set(["inbox", "common-prompts", "black-skies", "errors", "misc"]);
// ===============================================================
// DOM ELEMENTS
// ===============================================================

const sectionTabs = document.getElementById("sectionTabs");
const clipList = document.getElementById("clipList");

const textInput = document.getElementById("textInput");
const titleInput = document.getElementById("titleInput");
const notesInput = document.getElementById("notesInput");
const tagsInput = document.getElementById("tagsInput");
const screenshotBox = document.getElementById("screenshotContainer");
const screenshotModal = document.getElementById("screenshotModal");
const shotModalImage = document.getElementById("shotModalImage");

const sectionSelect = document.getElementById("sectionSelect");
const sourceUrlInput = document.getElementById("sourceUrlInput");
const sourceTitleInput = document.getElementById("sourceTitleInput");
const capturedAtInput = document.getElementById("capturedAtInput");
const titleRow = document.querySelector(".title-row");
const textRow = textInput ? textInput.closest(".field-row") : null;
const screenshotsRow = screenshotBox ? screenshotBox.closest(".field-row") : null;
const tagsRow = document.querySelector(".tags-row");
const tagsCol = document.querySelector(".tags-col");
const capturedCol = document.querySelector(".captured-col");
const sourceRow = document.querySelector(".source-row");
const sourceUrlCol = document.querySelector(".source-url");
const sourceTitleCol = sourceTitleInput ? sourceTitleInput.parentElement : null;
const notesRow = notesInput ? notesInput.closest(".field-row") : null;

const newClipBtn = document.getElementById("newClipBtn");
const newSnipBtn = document.getElementById("newSnipBtn");
const saveClipBtn = document.getElementById("saveClipBtn");
const deleteClipBtn = document.getElementById("deleteClipBtn");
const addShotBtn = document.getElementById("addShotBtn");

const searchInput = document.getElementById("searchInput");
const tagFilterInput = document.getElementById("tagFilterInput");
const topbarTools = document.getElementById("topbarTools");
const sortToggleBtn = document.getElementById("sortToggleBtn");
const filterToggleBtn = document.getElementById("filterToggleBtn");
const sortMenu = document.getElementById("sortMenu");
const filterMenu = document.getElementById("filterMenu");
const filterApplyBtn = document.getElementById("filterApplyBtn");
const filterClearBtn = document.getElementById("filterClearBtn");
const openSourceBtn = document.getElementById("openSourceBtn");
const listAddBtn = document.getElementById("listAddBtn");
const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
const listDeleteBtn = document.getElementById("listDeleteBtn");
const lockToggleBtn = document.getElementById("lockToggleBtn");
const setExportBtn = document.getElementById("setExportBtn");
const clearExportBtn = document.getElementById("clearExportBtn");
const exportPathDisplay = document.getElementById("exportPathDisplay");
const lockSectionCheckbox = null;
const tabContextMenu = document.getElementById("tabContextMenu");
const renameModal = document.getElementById("renameModal");
const renameInput = document.getElementById("renameInput");
const renameSaveBtn = document.getElementById("renameSaveBtn");
const renameCancelBtn = document.getElementById("renameCancelBtn");
const colorModal = document.getElementById("colorModal");
const colorSwatches = document.getElementById("colorSwatches");
const colorSaveBtn = document.getElementById("colorSaveBtn");
const colorCancelBtn = document.getElementById("colorCancelBtn");
const iconModal = document.getElementById("iconModal");
const iconChoicesContainer = document.getElementById("iconChoices");
const iconSaveBtn = document.getElementById("iconSaveBtn");
const iconCancelBtn = document.getElementById("iconCancelBtn");

// ---------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------

function getCurrentClip() {
  return state.clips.find(c => c.id === state.currentClipId) || null;
}

function closeQuickMenus() {
  if (sortMenu) sortMenu.classList.remove("is-open");
  if (filterMenu) filterMenu.classList.remove("is-open");
}

function toggleQuickMenu(menuEl) {
  if (!menuEl) return;
  const isOpen = menuEl.classList.contains("is-open");
  closeQuickMenus();
  if (!isOpen) menuEl.classList.add("is-open");
}

function pruneSelected() {
  const existingIds = new Set(state.clips.map((c) => c.id));
  state.selectedClipIds.forEach((id) => {
    if (!existingIds.has(id)) state.selectedClipIds.delete(id);
  });
}

function updateExportPathDisplay() {
  const activeTab = getActiveTab();
  if (!activeTab || state.activeTabId === "all") {
    exportPathDisplay.textContent = "No section selected";
    if (setExportBtn) setExportBtn.disabled = true;
    if (clearExportBtn) clearExportBtn.disabled = true;
    return;
  }
  if (setExportBtn) setExportBtn.disabled = true;
  if (clearExportBtn) clearExportBtn.disabled = true;
  const path = activeTab.exportFolder;
  exportPathDisplay.textContent = path || "(not set)";
}

function isSectionLocked(sectionId) {
  if (!sectionId || sectionId === "all") return false;
  const tab = state.tabs.find((t) => t.id === sectionId);
  if (tab) return !!tab.locked;
  return state.lockedSections.has(sectionId);
}

function syncLockedSectionsFromState() {
  const persisted = state.sections.filter((s) => s.locked).map((s) => s.id);
  state.lockedSections = new Set([...(state.lockedSections || []), ...persisted]);
}

async function updateSection(id, patch) {
  if (!id) return null;
  const current = state.sections.find((s) => s.id === id);
  if (current) {
    Object.assign(current, patch);
  }

  try {
    await invoke(CHANNELS.UPDATE_SECTION, { id, patch });
    if (patch.locked !== undefined) {
      await invoke(CHANNELS.SET_SECTION_LOCKED, { id, locked: patch.locked });
    }
    if (patch.exportFolder !== undefined || patch.exportPath !== undefined) {
      const pathVal = patch.exportFolder ?? patch.exportPath ?? "";
      await invoke(CHANNELS.SET_SECTION_EXPORT_PATH, { id, exportPath: pathVal });
    }
    await invoke(CHANNELS.SAVE_SECTION_ORDER, state.sections.map((s) => ({ id: s.id, name: s.name })));
  } catch (err) {
    console.error("[SnipBoard] updateSection failed:", err);
  }

  if (patch.locked !== undefined) {
    if (patch.locked) state.lockedSections.add(id);
    else state.lockedSections.delete(id);
  }

  return current;
}

function updateDeleteButtonsLockState() {
  const locked = isSectionLocked(state.currentSectionId);
  if (deleteClipBtn) deleteClipBtn.disabled = locked;
  if (deleteSelectedBtn) deleteSelectedBtn.disabled = locked;
  if (listDeleteBtn) listDeleteBtn.disabled = locked;
}

const lockSectionCheckboxHandler = () => {
  const id = state.currentSectionId;
  if (!id || id === "all") {
    return;
  }
  const next = !state.lockedSections.has(id);
  if (next) state.lockedSections.add(id);
  else state.lockedSections.delete(id);
  const sec = state.sections.find((s) => s.id === id);
  if (sec) sec.locked = next;
  updateSection(id, { locked: next });
  renderSections();
  updateDeleteButtonsLockState();
  renderLockButtonState();
};

function renderLockButtonState() {
  if (!lockToggleBtn) return;
  const locked = isSectionLocked(state.currentSectionId);
  lockToggleBtn.textContent = locked ? "\ud83d\udd12" : "\ud83d\udd13";
  lockToggleBtn.title = "Lock this section";
}

if (lockToggleBtn) {
  lockToggleBtn.addEventListener("click", lockSectionCheckboxHandler);
}

// ===============================================================
// RENDERING
// ===============================================================

function renderSections() {
  syncSectionsFromTabs();
  renderSectionsBar();
}

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    closeQuickMenus();
  }
});

/**
 * Delete one or more clips with confirmation and lock checks.
 * @param {string[]|null} ids
 */
async function unifiedDelete(ids) {
  const activeTab = window.tabsState?.tabs?.find(t => t.id === state.currentSectionId);
  if (activeTab?.locked) {
    console.warn("Tab is locked. Delete blocked.");
    return; 
  }
  const locked = isSectionLocked(state.currentSectionId);
  if (locked) {
    window.SnipToast?.show("This section is locked.");
    return;
  }

  const targets =
    Array.isArray(ids) && ids.length
      ? ids
      : state.currentClipId
      ? [state.currentClipId]
      : [];
  if (!targets.length) return;

  const confirmMsg =
    targets.length === 1 ? "Delete this clip?" : `Delete ${targets.length} selected clips?`;
  if (!window.confirm(confirmMsg)) return;

  const res = await invoke(CHANNELS.DELETE_CLIPS, targets);

  if (res && (res.blocked === true || (Array.isArray(res.blocked) && res.blocked.length))) {
    window.SnipToast?.show("Unlock section first.");
    return;
  }

  const data = await invoke(CHANNELS.GET_DATA);
  state.clips = (data.clips || []).map(normalizeClip);
  searchIndex = updateSearchIndex(state.clips);
  state.searchIndex = searchIndex;
  if (targets.includes(state.currentClipId)) {
    state.currentClipId = null;
  }
  await reloadTabsConfig();
  await refreshData();
  renderLockButtonState();
}

const tabsApi = initTabs ? initTabs({
  state: window.SnipState,
  appState: state,
  ipc: { CHANNELS, invoke, send, on },
  dom: {
    sectionTabs,
    tabContextMenu,
    colorModal,
    colorSwatches,
    iconModal,
    iconChoicesContainer,
    clipTabName: document.getElementById("clipTabName"),
    clipTabPath: document.getElementById("clipTabPath"),
    sortMenu,
    filterMenu,
    sortToggleBtn,
    filterToggleBtn,
    topbarTools,
  },
  helpers: {
    renderSections,
    renderClipList: renderClipListProxy,
    renderEditor,
    updateExportPathDisplay,
    updateDeleteButtonsLockState,
    renderLockButtonState,
    refreshData,
    updateSection,
    renameSection,
    closeQuickMenus,
    tabColors: SNIPBOARD_COLORS,
    protectedSections,
    draggingClip: {
      get: () => draggingClipId,
      clear: () => { draggingClipId = null; },
    },
  },
}) : {};
({
  getTabColorForClip = () => "",
  syncSectionsFromTabs = () => {},
  syncTabsToBackend = async () => {},
  renderTabs = () => {},
  setModalsApi: setTabsModalsApi,
  findIconChoice: tabsFindIconChoice = () => null,
  createIconGlyph: tabsCreateIconGlyph = () => document.createElement("span"),
  renderColorPalette: tabsRenderColorPalette = () => {},
  iconChoices: tabsIconChoices = iconChoices,
  setTabsEditorApi = () => {},
  onTabChangeTabs = () => {},
  getActiveTabSchema = () => DEFAULT_SCHEMA,
  getActiveTabId = () => "all",
} = tabsApi || {});

const clipsApi = initClips ? initClips({
  state: window.SnipState,
  appState: state,
  ipc: { CHANNELS, invoke, send, on },
  tabs: tabsApi,
  dom: {
    clipListContainer: clipList,
  },
    helpers: {
      findIconChoice: tabsFindIconChoice,
      createIconGlyph: tabsCreateIconGlyph,
      renderEditor,
      refreshData,
      getSearchIndexEntry: (id) => searchIndex.get(id),
      setDraggingClipId: (id) => { draggingClipId = id; state.draggingClipId = id; },
      clearDraggingClipId: () => { draggingClipId = null; state.draggingClipId = null; },
      getDraggingClipId: () => draggingClipId || state.draggingClipId,
      reloadTabsConfig,
    },
  }) : {};
({
  wireClipEvents = () => {},
  closeClipDisplayMenu = () => {},
  persistClipAppearance = async () => {},
  getSelectedClipIds = () => [],
  setModalsApi: setClipsModalsApi,
  applyTagFilterValue = () => {},
  setClipsEditorApi = () => {},
  onClipSelected = () => {},
} = clipsApi || {});

const modalsApi = window.SnipModals?.initModals({
  state,
  ipc: { CHANNELS, invoke, send, on },
  dom: {
    iconModal,
    iconChoicesContainer,
    iconSaveBtn,
    iconCancelBtn,
    colorModal,
    colorSwatches,
    colorSaveBtn,
    colorCancelBtn,
    renameModal,
    renameInput,
    renameSaveBtn,
    renameCancelBtn,
    screenshotModal,
    shotModalImage,
  },
  helpers: {
    renderColorPalette: tabsRenderColorPalette,
    iconChoices: tabsIconChoices,
    findIconChoice: tabsFindIconChoice,
    createIconGlyph: tabsCreateIconGlyph,
    updateSection,
    renderSectionsBar,
    renderTabs,
    scheduleSaveTabsConfig,
    refreshData,
    closeQuickMenus,
    commitRename,
    cancelRename,
    persistClipAppearance,
  },
});

if (modalsApi) {
  ({
    openClipIconPicker,
    openClipColorPicker,
    openRenameModal,
    closeRenameModal,
    openScreenshotModal,
    closeScreenshotModal,
  } = modalsApi);
  if (setTabsModalsApi) setTabsModalsApi(modalsApi);
  if (setClipsModalsApi) setClipsModalsApi(modalsApi);
}

const editorApi = initEditor ? initEditor({
  state,
  ipc: { CHANNELS, invoke, send, on },
  tabsApi,
  clipsApi,
  modalsApi,
  dom: {
    textInput,
    titleInput,
    notesInput,
    tagsInput,
    screenshotBox,
    sectionSelect,
    sourceUrlInput,
    sourceTitleInput,
    capturedAtInput,
    openSourceBtn,
    saveClipBtn,
    deleteClipBtn,
    titleRow,
    textRow,
    screenshotsRow,
    tagsRow,
    tagsCol,
    capturedCol,
    sourceRow,
    sourceUrlCol,
    sourceTitleCol,
    notesRow,
  },
  helpers: {
    normalizeClip,
    formatDateTime,
    refreshData,
    getCurrentClip,
    renderColorPalette: tabsRenderColorPalette,
    DEFAULT_CLIP_DISPLAY,
    unifiedDelete,
    DEFAULT_SCHEMA,
    validateText,
    validateUrl,
  },
}) : {};
({
  loadClipIntoEditor = async () => {},
  bindEditorEvents = () => {},
  saveClip = async () => {},
  deleteClip = async () => {},
  getEditorFieldValues = () => ({}),
  applySchemaVisibility: applySchemaVisibilityEditor = () => {},
} = editorApi || {});

if (typeof setTabsEditorApi === "function") {
  setTabsEditorApi(editorApi);
}
if (typeof setClipsEditorApi === "function") {
  setClipsEditorApi(editorApi);
}
if (typeof onTabChangeTabs === "function") {
  onTabChangeTabs(() => {
    reapplySchema();
  });
}
if (typeof onClipSelected === "function") {
  onClipSelected(() => {
    reapplySchema();
  });
}

function reapplySchema() {
  const schema = typeof getActiveTabSchema === "function" ? getActiveTabSchema() : DEFAULT_SCHEMA;
  if (schema && typeof applySchemaVisibilityEditor === "function") {
    applySchemaVisibilityEditor(schema);
  }
}

async function renderEditor() {
  await loadClipIntoEditor();
}

// ===============================================================
// EVENT HANDLERS
// ===============================================================

/**
 * Reload data from backend and refresh UI modules.
 * @param {string|null} selectId
 */
async function refreshData(selectId = null) {
  const data = await invoke(CHANNELS.GET_DATA);
  state.clips = (data.clips || []).map(normalizeClip);
  searchIndex = updateSearchIndex(state.clips);
  state.searchIndex = searchIndex;
  syncLockedSectionsFromState();
  if (selectId) {
    state.currentClipId = selectId;
    state.selectedClipIds = new Set([selectId]);
  }
  pruneSelected();
  renderSections();
  renderClipList();
  await renderEditor();
  updateExportPathDisplay();
  updateDeleteButtonsLockState();
  reapplySchema();
}

function currentSectionIdOrInbox() {
  if (state.currentSectionId && state.currentSectionId !== "all") return state.currentSectionId;
  return "inbox";
}

function bindHandlersOnce() {
  if (handlersBound) return;
  handlersBound = true;
  if (setExportBtn) setExportBtn.style.display = "none";
  if (clearExportBtn) clearExportBtn.style.display = "none";
  const exportActions = document.querySelector(".export-actions");
  if (exportActions) exportActions.style.display = "none";

  if (bindEditorEvents) bindEditorEvents();

  if (newClipBtn) newClipBtn.onclick = createClipboardClip;
  if (newSnipBtn) newSnipBtn.onclick = createScreenSnip;
  if (addShotBtn) addShotBtn.onclick = addScreenshotToCurrent;
  if (deleteSelectedBtn) deleteSelectedBtn.onclick = async () => { await unifiedDelete(getSelectedClipIds()); };
  if (listDeleteBtn) listDeleteBtn.onclick = async () => { await unifiedDelete(getSelectedClipIds()); };
  if (listAddBtn) listAddBtn.onclick = createClipboardClip;

  if (searchInput) {
    searchInput.addEventListener("input", () => {
      state.searchText = searchInput.value || "";
      renderClipList();
    });
  }
  if (sortToggleBtn) {
    sortToggleBtn.onclick = () => toggleQuickMenu(sortMenu);
  }
  if (filterToggleBtn) {
    filterToggleBtn.onclick = () => toggleQuickMenu(filterMenu);
  }
  if (tagFilterInput) {
    tagFilterInput.addEventListener("input", () => {
      applyTagFilterValue(tagFilterInput.value);
    });
    tagFilterInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        applyTagFilterValue(tagFilterInput.value);
        closeQuickMenus();
      }
    });
  }
  if (filterApplyBtn) {
    filterApplyBtn.onclick = () => {
      applyTagFilterValue(tagFilterInput ? tagFilterInput.value : "");
      closeQuickMenus();
    };
  }
  if (filterClearBtn) {
    filterClearBtn.onclick = () => {
      if (tagFilterInput) tagFilterInput.value = "";
      applyTagFilterValue("");
      closeQuickMenus();
    };
  }
  if (sortMenu) {
    sortMenu.querySelectorAll("input[name='sortMode']").forEach((radio) => {
      radio.addEventListener("change", () => {
        state.sortMode = radio.value || "default";
        renderClipList();
        closeQuickMenus();
      });
    });
  }

  const handleRenameSave = async () => {
    if (!state.pendingRenameSectionId) {
      closeRenameModal();
      return;
    }
    await commitRename(state.pendingRenameSectionId, renameInput ? renameInput.value : "");
  };

  if (renameSaveBtn) renameSaveBtn.onclick = handleRenameSave;
  if (renameCancelBtn) renameCancelBtn.onclick = closeRenameModal;
  if (renameInput) {
    renameInput.addEventListener("keydown", async (e) => {
      if (e.key === "Enter") {
        await handleRenameSave();
      } else if (e.key === "Escape") {
        closeRenameModal();
      }
    });
  }
  if (renameModal) {
    renameModal.addEventListener("click", (e) => {
      if (e.target === renameModal) closeRenameModal();
    });
  }

  if (setExportBtn) setExportBtn.onclick = null;
  if (clearExportBtn) clearExportBtn.onclick = null;
}
async function createClipboardClip() {
  const text = await invoke(CHANNELS.GET_CLIPBOARD_TEXT);
  const fallbackTitle = "Clipboard Snip";
  const clip = {
    id: null,
    title: (text || "").split("\n")[0].slice(0, 80) || fallbackTitle,
    text: text || "",
    notes: "",
    tags: [],
    screenshots: [],
    sectionId: currentSectionIdOrInbox(),
    capturedAt: Date.now(),
    icon: DEFAULT_CLIP_DISPLAY.icon,
    color: DEFAULT_CLIP_DISPLAY.color,
    appearanceColor: DEFAULT_CLIP_DISPLAY.appearanceColor,
  };
  state.currentSectionId = clip.sectionId;
  const saved = await invoke(CHANNELS.SAVE_CLIP, clip);
  if (saved?.exportFilename) clip.exportFilename = saved.exportFilename;
  await refreshData(saved.id);
}

async function createScreenSnip() {
  try {
    const capture = await invoke(CHANNELS.CAPTURE_SCREEN);
    if (!capture || !capture.success) {
      console.warn("[SnipBoard] captureScreen failed or returned empty payload", capture);
      return;
    }
    const filenames = Array.isArray(capture.screenshots)
      ? capture.screenshots.map((s) => s.filename)
      : [];
    if (Array.isArray(capture.screenshots)) {
      capture.screenshots.forEach((shot) => {
        // Optionally display previews using shot.dataUrl
        // e.g., add to UI if needed
      });
    }
    const clip = {
      id: null,
      title: "Screen Snip",
      text: "",
      notes: "",
    tags: [],
    screenshots: filenames,
    sectionId: currentSectionIdOrInbox(),
    capturedAt: Date.now(),
    icon: DEFAULT_CLIP_DISPLAY.icon,
    color: DEFAULT_CLIP_DISPLAY.color,
    appearanceColor: DEFAULT_CLIP_DISPLAY.appearanceColor,
  };
  state.currentSectionId = clip.sectionId;
  const saved = await invoke(CHANNELS.SAVE_CLIP, clip);
  if (saved?.exportFilename) clip.exportFilename = saved.exportFilename;
  await refreshData(saved.id);
  } catch (err) {
    console.error("[SnipBoard] createScreenSnip failed:", err);
  }
}

async function addScreenshotToCurrent() {
  const clip = getCurrentClip();
  if (!clip) return;
  try {
    const capture = await invoke(CHANNELS.CAPTURE_SCREEN);
    if (!capture || !capture.success) {
      console.warn("[SnipBoard] captureScreen failed or returned empty payload", capture);
      return;
    }
    const filenames = Array.isArray(capture.screenshots)
      ? capture.screenshots.map((s) => s.filename)
      : [];
    if (Array.isArray(capture.screenshots)) {
      capture.screenshots.forEach((shot) => {
        // Optionally display previews using shot.dataUrl
      });
    }
    clip.screenshots = [...(clip.screenshots || []), ...filenames];
    const saved = await invoke(CHANNELS.SAVE_CLIP, clip);
    if (saved?.exportFilename) clip.exportFilename = saved.exportFilename;
    await refreshData(saved.id);
  } catch (err) {
    console.error("[SnipBoard] addScreenshotToCurrent failed:", err);
  }
}

// ===============================================================
// INITIAL LOAD
// ===============================================================

/**
 * Bootstrap application: load data/tabs, init modules, bind events.
 */
async function init() {
  try {
    const data = await invoke(CHANNELS.GET_DATA);
    const tabsConfig = await invoke(CHANNELS.LOAD_TABS);
    const tabsFromConfig = normalizeTabs(tabsConfig?.tabs);
    const fallbackTabs = normalizeTabs(sectionsToTabs(data.sections || []));
    state.tabs = tabsFromConfig.length ? tabsFromConfig : fallbackTabs;
  state.sections = tabsToSections(state.tabs);
  state.activeTabId = tabsConfig?.activeTabId || state.tabs[0]?.id || "all";
  state.currentSectionId = state.activeTabId;
    state.clips = (data.clips || []).map(normalizeClip);
        searchIndex = updateSearchIndex(state.clips);
        state.searchIndex = searchIndex;
    syncLockedSectionsFromState();
    lastPollSignature = computeSignature(state.clips);
    state.searchText = searchInput ? searchInput.value || "" : "";
    state.tagFilter = tagFilterInput ? tagFilterInput.value || "" : "";
    const checkedSort = sortMenu ? sortMenu.querySelector("input[name='sortMode']:checked") : null;
    state.sortMode = checkedSort ? (checkedSort.value || "default") : "default";

    renderSectionsBar();
    window.tabsState = {
      tabs: state.tabs,
      activeTabId: state.activeTabId || "all",
    };
    renderTabs();
    renderClipList();
    await renderEditor();
    updateExportPathDisplay();
    updateDeleteButtonsLockState();
    renderLockButtonState();
    reapplySchema();
    updateSidebarHeader();
    bindHandlersOnce();
    if (wireClipEvents) wireClipEvents();
    await syncTabsToBackend();
  } catch (err) {
    console.error("[SnipBoard] init failed:", err);
  }

  // Polling loop: refresh clips/tabs when backend data changes.
  setInterval(async () => {
    try {
      const data = await invoke(CHANNELS.GET_DATA);
      const sig = computeSignature(data.clips || []);

      if (sig !== lastPollSignature) {
        state.clips = (data.clips || []).map(normalizeClip);
        searchIndex = updateSearchIndex(state.clips);
        state.searchIndex = searchIndex;
        syncLockedSectionsFromState();
        lastPollSignature = sig;
        pruneSelected();
        renderSectionsBar();
        renderClipList();
        await renderEditor();
        updateExportPathDisplay();
        updateDeleteButtonsLockState();
        renderLockButtonState();
        reapplySchema();
      }
    } catch (err) {
      console.warn("Backend poll failed:", err);
    }
  }, 3000);
}

document.addEventListener("DOMContentLoaded", init);
if (document.readyState !== "loading") {
  init();
}
document.addEventListener("DOMContentLoaded", () => {
  const tabsWrapper = sectionTabs && sectionTabs.parentElement;
  if (tabsWrapper && sectionTabs) {
    tabsWrapper.style.position = "relative";
    sectionTabs.style.overflowX = "auto";
    sectionTabs.style.whiteSpace = "nowrap";
  }
});

async function renameSection(id, newName) {
  const name = (newName || "").trim();
  if (!id || !name) return;
  try {
    const path = canonicalExportPath(name);
    const updated = await invoke(CHANNELS.RENAME_SECTION, { id, name });
    if (updated && updated.section) {
      const idx = state.sections.findIndex((s) => s.id === id);
      if (idx >= 0) {
        state.sections[idx] = {
          ...updated.section,
          exportPath: normalizeExportPath(updated.section.exportPath || updated.section.exportFolder || path, name),
          exportFolder: normalizeExportPath(updated.section.exportFolder || updated.section.exportPath || path, name),
        };
      }
    } else {
      const target = state.sections.find((s) => s.id === id);
      if (target) {
        target.name = name;
        target.exportPath = normalizeExportPath(target.exportPath || target.exportFolder || path, name);
        target.exportFolder = normalizeExportPath(target.exportFolder || target.exportPath || path, name);
      }
    }
    const tab = state.tabs.find((t) => t.id === id);
    if (tab) {
      tab.label = name;
      tab.name = name;
      tab.exportFolder = normalizeExportPath(tab.exportFolder || tab.exportPath || path, name);
      tab.exportPath = normalizeExportPath(tab.exportPath || tab.exportFolder || path, name);
    }
    await invoke(CHANNELS.SET_SECTION_EXPORT_PATH, { id, exportPath: path });
    state.sections = tabsToSections(state.tabs);
    scheduleSaveTabsConfig();
    renderSections();
    window.tabsState = { tabs: state.tabs, activeTabId: state.activeTabId || "all" };
    await invoke(CHANNELS.SAVE_TABS, window.tabsState);
  } catch (err) {
    console.error("[SnipBoard] renameSection failed:", err);
  }
}
